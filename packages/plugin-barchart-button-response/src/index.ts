import { JsPsych, JsPsychPlugin, ParameterType, TrialType } from "jspsych";
import Chart, { ChartData } from "chart.js/auto";
import annotationPlugin from "chartjs-plugin-annotation";
import { version } from "../package.json";

Chart.register(annotationPlugin);

interface ChartDataPoint {
  key: string;
  value: number;
}

const info = <const>{
  name: "plugin-barchart-button-response",
  version: version,
  parameters: {
    /**
     * Optional HTML content displayed above the chart. Can be used for instructions, context, or prompts.
     */
    description_text: {
      type: ParameterType.HTML_STRING,
      default: undefined,
    },
    /**
     * An array of data points to be displayed in the bar chart. Each data point should be an object with a `key` (string) and `value` (number).
     * Example: [{ key: "A", value: 0.3 }, { key: "B", value: 0.7 }]
     */
    chart_data: {
      type: ParameterType.OBJECT,
      array: true,
      default: undefined,
    },
    /**
     * The fill color for all bars that are not highlighted. Accepts any valid CSS color value.
     */
    base_color: {
      type: ParameterType.STRING,
      default: "#02c39a80",
    },
    /**
     * The `key` of the bar to be visually highlighted in a different color and annotated. Must match a `key` in `chart_data`.
     */
    highlight_value: {
      type: ParameterType.STRING,
      default: null,
    },
    /**
     * The fill color used for the highlighted bar. Accepts any valid CSS color value.
     */
    highlight_color: {
      type: ParameterType.STRING,
      default: "#fee44080",
    },
    /**
     * A text label used for the highlighted bar. Displayed as an annotation above the bar.
     */
    highlight_label: {
      type: ParameterType.STRING,
      default: null,
    },
    /**
     * The label for the y-axis of the chart.
     */
    y_axis_label: {
      type: ParameterType.STRING,
      default: "",
    },
    /**
     * The label for the x-axis of the chart.
     */
    x_axis_label: {
      type: ParameterType.STRING,
      default: "",
    },
    /**
     * If true, formats the y-axis as a percentage (0–1 scaled to 0–100%).
     */
    y_percent: {
      type: ParameterType.BOOL,
      default: false,
    },
    /**
     * If true, displays the chart legend on the right side.
     */
    show_legend: {
      type: ParameterType.BOOL,
      default: false,
    },
    /**
     * Labels for the response buttons. Each string in the array creates a separate button.
     */
    choices: {
      type: ParameterType.STRING,
      default: undefined,
      array: true,
    },
    /**
     * A function that generates the HTML for each button in the `choices` array.
     * Receives the `choice` string and its `index`, and returns a string of HTML.
     * Defaults to a standard jsPsych-style button.
     */
    button_html: {
      type: ParameterType.FUNCTION,
      default: function (choice: string, choice_index: number) {
        return `<button class="jspsych-btn">${choice}</button>`;
      },
    },
  },
  data: {
    /**
     * The response time in milliseconds, measured from when the chart is displayed until a button is clicked.
     */
    rt: {
      type: ParameterType.INT,
    },
    /**
     * The index of the button clicked by the participant (0-based).
     */
    response: {
      type: ParameterType.INT,
    },
  },
  citations: "__CITATIONS__",
};

type Info = typeof info;

/**
 * **plugin-barchart-button-response**
 *
 * The `barchart-button-response` plugin displays a bar chart and records responses generated by a button click. The chart can be displayed until a response is given, or for a pre-determined amount of time. The trial can be ended automatically if the participant does not respond within a fixed length of time. The buttons themselves can be customized using HTML formatting.
 * The bar chart stimulus is generated from an array of objects, where each object should contain a numeric `value` (used for the y-axis) and a string `key` (used for the x-axis label). One of the bars can optionally be highlighted in a distinct color and annotated with a text label.
 *
 * This plugin uses [Chart.js](https://www.chartjs.org/) under the hood, and supports features like axis labeling, legend display, and percentage formatting on the y-axis.
 *
 * @author
 * @see {@link /plugin-barchart-button-response/README.md}
 */
class BarchartButtonResponsePlugin implements JsPsychPlugin<Info> {
  static info = info;

  constructor(private jsPsych: JsPsych) {}

  //////////////////////////
  // DOM CREATION HELPERS //
  //////////////////////////

  private createDescriptiontext(
    html: string,
    display_element: HTMLElement
  ): void {
    const descriptionEl = document.createElement("div");
    descriptionEl.innerHTML = html;
    descriptionEl.style.marginBottom = "20px";
    display_element.appendChild(descriptionEl);
  }

  private createChartContainer(
    display_element: HTMLElement
  ): HTMLCanvasElement {
    const chartContainer = document.createElement("div");
    chartContainer.style.width = "600px";
    chartContainer.style.height = "400px";
    display_element.appendChild(chartContainer);

    const canvas = document.createElement("canvas");
    canvas.id = "chartCanvas";
    chartContainer.appendChild(canvas);

    return canvas;
  }

  private createButtonGroup(
    trial: TrialType<Info>,
    after_response: (choiceIndex: number) => void
  ): HTMLDivElement {
    const buttonGroupElement = document.createElement("div");
    buttonGroupElement.id = "jspsych-html-button-response-btngroup";

    if (trial.button_layout === "grid") {
      buttonGroupElement.classList.add("jspsych-btn-group-grid");

      if (trial.grid_rows === null && trial.grid_columns === null) {
        throw new Error(
          "You cannot set `grid_rows` to `null` without providing a value for `grid_columns`."
        );
      }

      const n_cols =
        trial.grid_columns === null
          ? Math.ceil(trial.choices.length / (trial.grid_rows as number))
          : trial.grid_columns;

      const n_rows =
        trial.grid_rows === null
          ? Math.ceil(trial.choices.length / (trial.grid_columns as number))
          : trial.grid_rows;

      buttonGroupElement.style.gridTemplateColumns = `repeat(${n_cols}, 1fr)`;
      buttonGroupElement.style.gridTemplateRows = `repeat(${n_rows}, 1fr)`;
    } else if (trial.button_layout === "flex") {
      buttonGroupElement.classList.add("jspsych-btn-group-flex");
    }

    for (const [choiceIndex, choice] of trial.choices.entries()) {
      buttonGroupElement.insertAdjacentHTML(
        "beforeend",
        trial.button_html(choice, choiceIndex)
      );
      const buttonElement = buttonGroupElement.lastChild as HTMLElement;
      buttonElement.dataset.choice = choiceIndex.toString();
      buttonElement.addEventListener("click", () => {
        after_response(choiceIndex);
      });
    }

    return buttonGroupElement;
  }

  ///////////////////
  // CHART HELPERS //
  ///////////////////

  private prepareChartData(trial: TrialType<Info>): {
    dataPoints: ChartDataPoint[];
    chartData: ChartData<"bar", { key: string; value: number }[]>;
  } {
    const dataPoints = trial.chart_data as ChartDataPoint[];

    const regularData = dataPoints.map(({ key, value }) => ({
      key,
      value: key === trial.highlight_value ? null : value,
    }));

    const highlightData = dataPoints.map(({ key, value }) => ({
      key,
      value: key === trial.highlight_value ? value : null,
    }));

    const chartData = {
      datasets: [
        {
          data: regularData as { key: string; value: number }[],
          backgroundColor: trial.base_color,
          parsing: {
            xAxisKey: "key",
            yAxisKey: "value",
          },
          stack: "stack1",
        },
        {
          label: trial.highlight_label,
          data: highlightData as { key: string; value: number }[],
          backgroundColor: trial.highlight_color,
          parsing: {
            xAxisKey: "key",
            yAxisKey: "value",
          },
          stack: "stack1",
        },
      ],
    };

    return { dataPoints, chartData };
  }

  private renderChart(
    canvas: HTMLCanvasElement,
    chartData: ChartData<"bar", { key: string; value: number }[]>,
    trial: TrialType<Info>,
    dataPoints: ChartDataPoint[]
  ): void {
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      console.error("Your browser does not support canvas rendering.");
      return;
    }

    new Chart(ctx, {
      type: "bar",
      data: chartData,
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            stacked: true,
            title: {
              display: true,
              text: trial.x_axis_label,
              font: {
                size: 18,
              },
            },
          },
          y: trial.y_percent
            ? {
                stacked: true,
                min: 0,
                max: 1,
                title: {
                  display: true,
                  text: trial.y_axis_label,
                  font: {
                    size: 18,
                  },
                },
                ticks: {
                  callback: (value) => `${(+value * 100).toFixed(0)}%`,
                },
              }
            : {
                stacked: true,
                title: {
                  display: true,
                  text: trial.y_axis_label,
                },
              },
        },
        plugins: {
          legend: {
            position: "right",
            display: trial.show_legend,
          },
          annotation: {
            annotations: {
              highlightLabel: trial.highlight_value != null && {
                type: "label",
                xValue: trial.highlight_value.toString(),
                yValue:
                  dataPoints.find((d) => d.key === trial.highlight_value)
                    ?.value ?? 0,
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "rgba(0,0,0,0)",
                content: trial.highlight_label != null && [
                  trial.highlight_label,
                  "↓",
                ],
                font: {
                  size: 18,
                  weight: "bold",
                },
                position: {
                  x: "center",
                  y: "center",
                },
                yAdjust: -35,
              },
            },
          },
        },
      },
    });
  }

  //////////////////////
  // RESPONSE HELPERS //
  //////////////////////

  private endTrial(response: { rt: number; button: number }): void {
    const trial_data = {
      rt: response.rt,
      // stimulus: trial.stimulus, // uncomment if needed
      response: response.button,
    };

    this.jsPsych.finishTrial(trial_data);
  }

  private handleResponse(
    choice: number,
    start_time: number,
    response: { rt: number; button: number },
    buttonGroupElement: HTMLElement
  ): void {
    const end_time = performance.now();
    const rt = Math.round(end_time - start_time);
    response.button = parseInt(choice.toString());
    response.rt = rt;

    for (const button of Array.from(buttonGroupElement.children)) {
      button.setAttribute("disabled", "disabled");
    }

    this.endTrial(response);
  }

  //////////////////////////
  // JSPSYCH TRIAL METHOD //
  //////////////////////////

  trial(display_element: HTMLElement, trial: TrialType<Info>) {
    // clear the display element
    display_element.innerHTML = "";

    // create and append the description text, if provided
    trial.description_text &&
      this.createDescriptiontext(trial.description_text, display_element);

    // create container for chart
    const canvas = this.createChartContainer(display_element);

    // prepare chart data
    const { dataPoints, chartData } = this.prepareChartData(trial);

    // initialize the Chart.js chart
    this.renderChart(canvas, chartData, trial, dataPoints);

    // handle responses by the subject and end trial
    const after_response = (choice: number) => {
      this.handleResponse(choice, start_time, response, buttonGroupElement);
    };

    // start time
    const start_time = performance.now();

    // store response
    const response = {
      rt: null,
      button: null,
    };

    // display response buttons
    const buttonGroupElement = this.createButtonGroup(trial, after_response);
    display_element.appendChild(buttonGroupElement);
  }
}

export default BarchartButtonResponsePlugin;
