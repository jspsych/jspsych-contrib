import { JsPsych, JsPsychPlugin, ParameterType, TrialType } from "jspsych";
import Chart, { ChartData } from "chart.js/auto";
import annotationPlugin from "chartjs-plugin-annotation";
import { version } from "../package.json";

Chart.register(annotationPlugin);

const info = <const>{
  name: "plugin-densitychart-button-response",
  version: version,
  parameters: {
    /**
     * Optional HTML content shown above the chart. Can be used for instructions, prompts, or other text.
     */
    description_text: {
      type: ParameterType.HTML_STRING,
      default: undefined,
    },

    /**
     * Required array of numeric values used to generate the kernel density estimate (KDE).
     */
    chart_data: {
      type: ParameterType.FLOAT,
      array: true,
      default: undefined,
    },

    /**
     * Number of evenly spaced grid points used to compute the KDE curve.
     * Higher values yield smoother estimates but increase computation time.
     */
    n_grid_points: {
      type: ParameterType.INT,
      default: 100,
    },

    /**
     * Maximum number of ticks shown on the x-axis.
     */
    n_x_labels: {
      type: ParameterType.INT,
      default: 5,
    },

    /**
     * Maximum number of ticks shown on the y-axis.
     */
    n_y_labels: {
      type: ParameterType.INT,
      default: 5,
    },

    /**
     * Primary color used for the density curve and fill area. Accepts any valid CSS color.
     */
    base_color: {
      type: ParameterType.STRING,
      default: "#02c39a80",
    },

    /**
     * Color of the vertical line annotation for the highlighted score.
     */
    highlight_color: {
      type: ParameterType.STRING,
      default: "#ff1100",
    },

    /**
     * A numeric value that will be highlighted on the x-axis with a vertical line and label.
     * Must fall within the range of `chart_data`.
     */
    highlight_score: {
      type: ParameterType.FLOAT,
      default: null,
    },

    /**
     * Text label shown next to the vertical line at the `highlight_score` location.
     */
    highlight_label: {
      type: ParameterType.STRING,
      default: null,
    },

    /**
     * Label text shown below the x-axis.
     */
    x_axis_label: {
      type: ParameterType.STRING,
      default: "",
    },

    /**
     * Label text shown beside the y-axis.
     */
    y_axis_label: {
      type: ParameterType.STRING,
      default: "",
    },

    /**
     * Whether to display a legend beside the chart.
     */
    show_legend: {
      type: ParameterType.BOOL,
      default: false,
    },

    /**
     * Labels for the response buttons. Each entry generates one button.
     */
    choices: {
      type: ParameterType.STRING,
      array: true,
      default: undefined,
    },

    /**
     * A function that returns the HTML for each button.
     * The function receives the choice label and index as arguments.
     * By default, creates a standard jsPsych button with the choice text.
     */
    button_html: {
      type: ParameterType.FUNCTION,
      default: function (choice: string, choice_index: number) {
        return `<button class="jspsych-btn">${choice}</button>`;
      },
    },

    /**
     * Bandwidth parameter used for kernel smoothing.
     * Higher values result in smoother, flatter density curves.
     */
    bandwidth: {
      type: ParameterType.FLOAT,
      default: 10,
    },
  },

  data: {
    /**
     * Response time in milliseconds, measured from when the trial starts to when a button is clicked.
     */
    rt: {
      type: ParameterType.INT,
    },

    /**
     * Index (0-based) of the button clicked by the participant.
     */
    response: {
      type: ParameterType.INT,
    },
  },

  citations: "__CITATIONS__",
};

type Info = typeof info;

type TrialResponse = {
  rt: number | null;
  button: number | null;
};

/**
 * **plugin-densitychart-button-response**
 * The `densitychart-button-response` plugin displays a density plot chart and records responses generated by a button click. The chart can be displayed until a response is given, or for a pre-determined amount of time.
 * The trial can be ended automatically if the participant does not respond within a fixed length of time. The button itself can be customized using HTML formatting.
 * The density plot stimulus is generated from a numeric array of data, with optional parameters for customizing how smooth the densities are and the colours used.
 * You can also add an annotation to the chart indicated by a vertical line with an accompanying text annotation.
 *
 * This plugin uses [Chart.js](https://www.chartjs.org/) under the hood, and supports features like axis labeling, legend display, and percentage formatting on the y-axis.
 */
class DensityChartButtonResponsePlugin implements JsPsychPlugin<Info> {
  static info = info;

  constructor(private jsPsych: JsPsych) {}

  //////////////////////////
  // DOM CREATION HELPERS //
  //////////////////////////

  private createDescription(html: string, display_element: HTMLElement): void {
    const descriptionEl = document.createElement("div");
    descriptionEl.innerHTML = html;
    descriptionEl.style.marginBottom = "20px";
    display_element.appendChild(descriptionEl);
  }

  private createChartCanvas(display_element: HTMLElement): HTMLCanvasElement {
    const chartContainer = document.createElement("div");
    chartContainer.style.width = "600px";
    chartContainer.style.height = "400px";
    chartContainer.style.margin = "auto";
    display_element.appendChild(chartContainer);

    const canvas = document.createElement("canvas");
    canvas.id = "chartCanvas";
    chartContainer.appendChild(canvas);

    return canvas;
  }

  private createButtonGroup(
    trial: TrialType<Info>,
    after_response: (choiceIndex: number) => void
  ): HTMLDivElement {
    const buttonGroupElement = document.createElement("div");
    buttonGroupElement.id = "jspsych-density-chart-btngroup";
    buttonGroupElement.classList.add("jspsych-btn-group-flex");

    for (const [choiceIndex, choice] of trial.choices.entries()) {
      buttonGroupElement.insertAdjacentHTML(
        "beforeend",
        trial.button_html(choice, choiceIndex)
      );
      const buttonElement = buttonGroupElement.lastChild as HTMLElement;
      buttonElement.dataset.choice = choiceIndex.toString();
      buttonElement.addEventListener("click", () => {
        after_response(choiceIndex);
      });
    }

    return buttonGroupElement;
  }

  ///////////////////
  // CHART HELPERS //
  ///////////////////

  private computeDensity(
    rawData: number[],
    nPoints: number,
    bandwidth: number
  ): { grid: number[]; density: number[] } {
    const minValue = Math.min(...rawData);
    const maxValue = Math.max(...rawData);
    const step = (maxValue - minValue) / (nPoints - 1);

    const grid: number[] = Array.from(
      { length: nPoints },
      (_, i) => minValue + i * step
    );

    const gaussian = (u: number): number =>
      (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-0.5 * u * u);

    const density = grid.map((x) => {
      const sum = rawData.reduce(
        (acc, v) => acc + gaussian((x - v) / bandwidth),
        0
      );
      return sum / (rawData.length * bandwidth);
    });

    return { grid, density };
  }

  private renderChart(
    canvas: HTMLCanvasElement,
    grid: number[],
    density: number[],
    trial: TrialType<Info>
  ): void {
    const highlightIndex = Math.round(
      (trial.highlight_score - grid[0]) / (grid[1] - grid[0])
    );
    const clampedIndex = Math.min(Math.max(highlightIndex, 0), grid.length - 1);
    const highlightX = grid[clampedIndex];
    const highlightY = density[clampedIndex];

    const chartData: ChartData<"line", number[]> = {
      labels: grid.map((x) => x.toFixed(1)),
      datasets: [
        {
          data: density,
          borderColor: trial.base_color,
          backgroundColor: trial.base_color,
          fill: true,
          tension: 0.3,
          pointRadius: 0,
        },
      ],
    };

    const ctx = canvas.getContext("2d");
    if (!ctx) {
      console.error("Your browser does not support canvas rendering.");
      return;
    }

    new Chart(ctx, {
      type: "line",
      data: chartData,
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            title: {
              display: true,
              text: trial.x_axis_label,
              font: {
                size: 18,
              },
            },
            ticks: {
              maxTicksLimit: trial.n_x_labels,
            },
          },
          y: {
            title: {
              display: true,
              text: trial.y_axis_label,
            },
            ticks: {
              maxTicksLimit: trial.n_y_labels,
            },
          },
        },
        plugins: {
          legend: {
            position: "right",
            display: trial.show_legend,
          },
          annotation: {
            annotations: {
              highlightLine: {
                type: "line",
                scaleID: "x",
                value: highlightX,
                borderColor: trial.highlight_color,
                borderWidth: 2,
              },
              highlightLabel: {
                type: "label",
                xScaleID: "x",
                yScaleID: "y",
                xValue: highlightX,
                yValue: highlightY,
                content: "‚Üê" + trial.highlight_label,
                display: true,
                backgroundColor: "rgba(0,0,0,0)",
                font: {
                  size: 18,
                  weight: "bold",
                },
                xAdjust: 30,
                yAdjust: -15,
              },
            },
          },
        },
      },
    });
  }

  //////////////////////
  // RESPONSE HELPERS //
  //////////////////////

  private handleResponse(
    choice: number,
    start_time: number,
    response: TrialResponse,
    buttonGroupElement: HTMLElement,
    trial: TrialType<Info>
  ): void {
    const end_time = performance.now();
    response.rt = Math.round(end_time - start_time);
    response.button = choice;

    for (const button of Array.from(buttonGroupElement.children)) {
      button.setAttribute("disabled", "disabled");
    }

    if (trial.response_ends_trial) {
      this.endTrial(response);
    }
  }

  private endTrial(response: TrialResponse): void {
    const trial_data = {
      rt: response.rt,
      response: response.button,
    };
    this.jsPsych.finishTrial(trial_data);
  }

  //////////////////////////
  // JSPSYCH TRIAL METHOD //
  //////////////////////////

  trial(display_element: HTMLElement, trial: TrialType<Info>): void {
    // clear the display element
    display_element.innerHTML = "";

    // create and append the description text, if provided
    trial.description_text &&
      this.createDescription(trial.description_text, display_element);

    // create container for chart
    const canvas = this.createChartCanvas(display_element);

    // prepare chart data
    const { grid, density } = this.computeDensity(
      trial.chart_data,
      trial.n_grid_points,
      trial.bandwidth
    );

    // initialize the Chart.js chart
    this.renderChart(canvas, grid, density, trial);

    // start time
    const start_time = performance.now();

    // store response
    const response: TrialResponse = {
      rt: null,
      button: null,
    };

    // handle responses by the subject and end trial
    const after_response = (choice: number) => {
      this.handleResponse(
        choice,
        start_time,
        response,
        buttonGroupElement,
        trial
      );
    };

    // display response buttons
    const buttonGroupElement = this.createButtonGroup(trial, after_response);
    display_element.appendChild(buttonGroupElement);
  }
}

export default DensityChartButtonResponsePlugin;
